// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: ecooda/v1/ecooda.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	LocationService_GetLocationFromChallenge_FullMethodName    = "/ecooda.v1.LocationService/GetLocationFromChallenge"
	LocationService_GetLocationCollection_FullMethodName       = "/ecooda.v1.LocationService/GetLocationCollection"
	LocationService_GetLocationItem_FullMethodName             = "/ecooda.v1.LocationService/GetLocationItem"
	LocationService_CreateLocation_FullMethodName              = "/ecooda.v1.LocationService/CreateLocation"
	LocationService_UpdateLocation_FullMethodName              = "/ecooda.v1.LocationService/UpdateLocation"
	LocationService_DeleteLocation_FullMethodName              = "/ecooda.v1.LocationService/DeleteLocation"
	LocationService_AddCountryToLocation_FullMethodName        = "/ecooda.v1.LocationService/AddCountryToLocation"
	LocationService_AddRegionToLocation_FullMethodName         = "/ecooda.v1.LocationService/AddRegionToLocation"
	LocationService_RemoveCountryFromLocation_FullMethodName   = "/ecooda.v1.LocationService/RemoveCountryFromLocation"
	LocationService_RemoveRegionFromLocation_FullMethodName    = "/ecooda.v1.LocationService/RemoveRegionFromLocation"
	LocationService_AddChallengeToLocation_FullMethodName      = "/ecooda.v1.LocationService/AddChallengeToLocation"
	LocationService_RemoveChallengeFromLocation_FullMethodName = "/ecooda.v1.LocationService/RemoveChallengeFromLocation"
	LocationService_GetChallengesFromLocation_FullMethodName   = "/ecooda.v1.LocationService/GetChallengesFromLocation"
)

// LocationServiceClient is the client API for LocationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocationServiceClient interface {
	// private api
	GetLocationFromChallenge(ctx context.Context, in *GetLocationFromChallengeRequest, opts ...grpc.CallOption) (*GetLocationFromChallengeResponse, error)
	// public API
	GetLocationCollection(ctx context.Context, in *GetLocationCollectionRequest, opts ...grpc.CallOption) (*GetLocationCollectionResponse, error)
	GetLocationItem(ctx context.Context, in *GetLocationItemRequest, opts ...grpc.CallOption) (*GetLocationItemResponse, error)
	CreateLocation(ctx context.Context, in *CreateLocationRequest, opts ...grpc.CallOption) (*CreateLocationResponse, error)
	UpdateLocation(ctx context.Context, in *UpdateLocationRequest, opts ...grpc.CallOption) (*UpdateLocationResponse, error)
	DeleteLocation(ctx context.Context, in *DeleteLocationRequest, opts ...grpc.CallOption) (*DeleteLocationResponse, error)
	AddCountryToLocation(ctx context.Context, in *AddCountryToLocationRequest, opts ...grpc.CallOption) (*AddCountryToLocationResponse, error)
	AddRegionToLocation(ctx context.Context, in *AddRegionToLocationRequest, opts ...grpc.CallOption) (*AddRegionToLocationResponse, error)
	RemoveCountryFromLocation(ctx context.Context, in *RemoveCountryFromLocationRequest, opts ...grpc.CallOption) (*RemoveCountryFromLocationResponse, error)
	RemoveRegionFromLocation(ctx context.Context, in *RemoveRegionFromLocationRequest, opts ...grpc.CallOption) (*RemoveRegionFromLocationResponse, error)
	AddChallengeToLocation(ctx context.Context, in *AddChallengeToLocationRequest, opts ...grpc.CallOption) (*AddChallengeToLocationResponse, error)
	RemoveChallengeFromLocation(ctx context.Context, in *RemoveChallengeFromLocationRequest, opts ...grpc.CallOption) (*RemoveChallengeFromLocationResponse, error)
	GetChallengesFromLocation(ctx context.Context, in *GetChallengesFromLocationRequest, opts ...grpc.CallOption) (*GetChallengesFromLocationResponse, error)
}

type locationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLocationServiceClient(cc grpc.ClientConnInterface) LocationServiceClient {
	return &locationServiceClient{cc}
}

func (c *locationServiceClient) GetLocationFromChallenge(ctx context.Context, in *GetLocationFromChallengeRequest, opts ...grpc.CallOption) (*GetLocationFromChallengeResponse, error) {
	out := new(GetLocationFromChallengeResponse)
	err := c.cc.Invoke(ctx, LocationService_GetLocationFromChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) GetLocationCollection(ctx context.Context, in *GetLocationCollectionRequest, opts ...grpc.CallOption) (*GetLocationCollectionResponse, error) {
	out := new(GetLocationCollectionResponse)
	err := c.cc.Invoke(ctx, LocationService_GetLocationCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) GetLocationItem(ctx context.Context, in *GetLocationItemRequest, opts ...grpc.CallOption) (*GetLocationItemResponse, error) {
	out := new(GetLocationItemResponse)
	err := c.cc.Invoke(ctx, LocationService_GetLocationItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) CreateLocation(ctx context.Context, in *CreateLocationRequest, opts ...grpc.CallOption) (*CreateLocationResponse, error) {
	out := new(CreateLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_CreateLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) UpdateLocation(ctx context.Context, in *UpdateLocationRequest, opts ...grpc.CallOption) (*UpdateLocationResponse, error) {
	out := new(UpdateLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_UpdateLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) DeleteLocation(ctx context.Context, in *DeleteLocationRequest, opts ...grpc.CallOption) (*DeleteLocationResponse, error) {
	out := new(DeleteLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_DeleteLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) AddCountryToLocation(ctx context.Context, in *AddCountryToLocationRequest, opts ...grpc.CallOption) (*AddCountryToLocationResponse, error) {
	out := new(AddCountryToLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_AddCountryToLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) AddRegionToLocation(ctx context.Context, in *AddRegionToLocationRequest, opts ...grpc.CallOption) (*AddRegionToLocationResponse, error) {
	out := new(AddRegionToLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_AddRegionToLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) RemoveCountryFromLocation(ctx context.Context, in *RemoveCountryFromLocationRequest, opts ...grpc.CallOption) (*RemoveCountryFromLocationResponse, error) {
	out := new(RemoveCountryFromLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_RemoveCountryFromLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) RemoveRegionFromLocation(ctx context.Context, in *RemoveRegionFromLocationRequest, opts ...grpc.CallOption) (*RemoveRegionFromLocationResponse, error) {
	out := new(RemoveRegionFromLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_RemoveRegionFromLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) AddChallengeToLocation(ctx context.Context, in *AddChallengeToLocationRequest, opts ...grpc.CallOption) (*AddChallengeToLocationResponse, error) {
	out := new(AddChallengeToLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_AddChallengeToLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) RemoveChallengeFromLocation(ctx context.Context, in *RemoveChallengeFromLocationRequest, opts ...grpc.CallOption) (*RemoveChallengeFromLocationResponse, error) {
	out := new(RemoveChallengeFromLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_RemoveChallengeFromLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationServiceClient) GetChallengesFromLocation(ctx context.Context, in *GetChallengesFromLocationRequest, opts ...grpc.CallOption) (*GetChallengesFromLocationResponse, error) {
	out := new(GetChallengesFromLocationResponse)
	err := c.cc.Invoke(ctx, LocationService_GetChallengesFromLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocationServiceServer is the server API for LocationService service.
// All implementations must embed UnimplementedLocationServiceServer
// for forward compatibility
type LocationServiceServer interface {
	// private api
	GetLocationFromChallenge(context.Context, *GetLocationFromChallengeRequest) (*GetLocationFromChallengeResponse, error)
	// public API
	GetLocationCollection(context.Context, *GetLocationCollectionRequest) (*GetLocationCollectionResponse, error)
	GetLocationItem(context.Context, *GetLocationItemRequest) (*GetLocationItemResponse, error)
	CreateLocation(context.Context, *CreateLocationRequest) (*CreateLocationResponse, error)
	UpdateLocation(context.Context, *UpdateLocationRequest) (*UpdateLocationResponse, error)
	DeleteLocation(context.Context, *DeleteLocationRequest) (*DeleteLocationResponse, error)
	AddCountryToLocation(context.Context, *AddCountryToLocationRequest) (*AddCountryToLocationResponse, error)
	AddRegionToLocation(context.Context, *AddRegionToLocationRequest) (*AddRegionToLocationResponse, error)
	RemoveCountryFromLocation(context.Context, *RemoveCountryFromLocationRequest) (*RemoveCountryFromLocationResponse, error)
	RemoveRegionFromLocation(context.Context, *RemoveRegionFromLocationRequest) (*RemoveRegionFromLocationResponse, error)
	AddChallengeToLocation(context.Context, *AddChallengeToLocationRequest) (*AddChallengeToLocationResponse, error)
	RemoveChallengeFromLocation(context.Context, *RemoveChallengeFromLocationRequest) (*RemoveChallengeFromLocationResponse, error)
	GetChallengesFromLocation(context.Context, *GetChallengesFromLocationRequest) (*GetChallengesFromLocationResponse, error)
	mustEmbedUnimplementedLocationServiceServer()
}

// UnimplementedLocationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLocationServiceServer struct {
}

func (UnimplementedLocationServiceServer) GetLocationFromChallenge(context.Context, *GetLocationFromChallengeRequest) (*GetLocationFromChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocationFromChallenge not implemented")
}
func (UnimplementedLocationServiceServer) GetLocationCollection(context.Context, *GetLocationCollectionRequest) (*GetLocationCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocationCollection not implemented")
}
func (UnimplementedLocationServiceServer) GetLocationItem(context.Context, *GetLocationItemRequest) (*GetLocationItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocationItem not implemented")
}
func (UnimplementedLocationServiceServer) CreateLocation(context.Context, *CreateLocationRequest) (*CreateLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLocation not implemented")
}
func (UnimplementedLocationServiceServer) UpdateLocation(context.Context, *UpdateLocationRequest) (*UpdateLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLocation not implemented")
}
func (UnimplementedLocationServiceServer) DeleteLocation(context.Context, *DeleteLocationRequest) (*DeleteLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLocation not implemented")
}
func (UnimplementedLocationServiceServer) AddCountryToLocation(context.Context, *AddCountryToLocationRequest) (*AddCountryToLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCountryToLocation not implemented")
}
func (UnimplementedLocationServiceServer) AddRegionToLocation(context.Context, *AddRegionToLocationRequest) (*AddRegionToLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRegionToLocation not implemented")
}
func (UnimplementedLocationServiceServer) RemoveCountryFromLocation(context.Context, *RemoveCountryFromLocationRequest) (*RemoveCountryFromLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCountryFromLocation not implemented")
}
func (UnimplementedLocationServiceServer) RemoveRegionFromLocation(context.Context, *RemoveRegionFromLocationRequest) (*RemoveRegionFromLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRegionFromLocation not implemented")
}
func (UnimplementedLocationServiceServer) AddChallengeToLocation(context.Context, *AddChallengeToLocationRequest) (*AddChallengeToLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddChallengeToLocation not implemented")
}
func (UnimplementedLocationServiceServer) RemoveChallengeFromLocation(context.Context, *RemoveChallengeFromLocationRequest) (*RemoveChallengeFromLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveChallengeFromLocation not implemented")
}
func (UnimplementedLocationServiceServer) GetChallengesFromLocation(context.Context, *GetChallengesFromLocationRequest) (*GetChallengesFromLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChallengesFromLocation not implemented")
}
func (UnimplementedLocationServiceServer) mustEmbedUnimplementedLocationServiceServer() {}

// UnsafeLocationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocationServiceServer will
// result in compilation errors.
type UnsafeLocationServiceServer interface {
	mustEmbedUnimplementedLocationServiceServer()
}

func RegisterLocationServiceServer(s grpc.ServiceRegistrar, srv LocationServiceServer) {
	s.RegisterService(&LocationService_ServiceDesc, srv)
}

func _LocationService_GetLocationFromChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationFromChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).GetLocationFromChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_GetLocationFromChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).GetLocationFromChallenge(ctx, req.(*GetLocationFromChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_GetLocationCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).GetLocationCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_GetLocationCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).GetLocationCollection(ctx, req.(*GetLocationCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_GetLocationItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).GetLocationItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_GetLocationItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).GetLocationItem(ctx, req.(*GetLocationItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_CreateLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).CreateLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_CreateLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).CreateLocation(ctx, req.(*CreateLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_UpdateLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).UpdateLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_UpdateLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).UpdateLocation(ctx, req.(*UpdateLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_DeleteLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).DeleteLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_DeleteLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).DeleteLocation(ctx, req.(*DeleteLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_AddCountryToLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCountryToLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).AddCountryToLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_AddCountryToLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).AddCountryToLocation(ctx, req.(*AddCountryToLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_AddRegionToLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRegionToLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).AddRegionToLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_AddRegionToLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).AddRegionToLocation(ctx, req.(*AddRegionToLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_RemoveCountryFromLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCountryFromLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).RemoveCountryFromLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_RemoveCountryFromLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).RemoveCountryFromLocation(ctx, req.(*RemoveCountryFromLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_RemoveRegionFromLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRegionFromLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).RemoveRegionFromLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_RemoveRegionFromLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).RemoveRegionFromLocation(ctx, req.(*RemoveRegionFromLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_AddChallengeToLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddChallengeToLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).AddChallengeToLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_AddChallengeToLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).AddChallengeToLocation(ctx, req.(*AddChallengeToLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_RemoveChallengeFromLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveChallengeFromLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).RemoveChallengeFromLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_RemoveChallengeFromLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).RemoveChallengeFromLocation(ctx, req.(*RemoveChallengeFromLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocationService_GetChallengesFromLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChallengesFromLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServiceServer).GetChallengesFromLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocationService_GetChallengesFromLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServiceServer).GetChallengesFromLocation(ctx, req.(*GetChallengesFromLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LocationService_ServiceDesc is the grpc.ServiceDesc for LocationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LocationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ecooda.v1.LocationService",
	HandlerType: (*LocationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLocationFromChallenge",
			Handler:    _LocationService_GetLocationFromChallenge_Handler,
		},
		{
			MethodName: "GetLocationCollection",
			Handler:    _LocationService_GetLocationCollection_Handler,
		},
		{
			MethodName: "GetLocationItem",
			Handler:    _LocationService_GetLocationItem_Handler,
		},
		{
			MethodName: "CreateLocation",
			Handler:    _LocationService_CreateLocation_Handler,
		},
		{
			MethodName: "UpdateLocation",
			Handler:    _LocationService_UpdateLocation_Handler,
		},
		{
			MethodName: "DeleteLocation",
			Handler:    _LocationService_DeleteLocation_Handler,
		},
		{
			MethodName: "AddCountryToLocation",
			Handler:    _LocationService_AddCountryToLocation_Handler,
		},
		{
			MethodName: "AddRegionToLocation",
			Handler:    _LocationService_AddRegionToLocation_Handler,
		},
		{
			MethodName: "RemoveCountryFromLocation",
			Handler:    _LocationService_RemoveCountryFromLocation_Handler,
		},
		{
			MethodName: "RemoveRegionFromLocation",
			Handler:    _LocationService_RemoveRegionFromLocation_Handler,
		},
		{
			MethodName: "AddChallengeToLocation",
			Handler:    _LocationService_AddChallengeToLocation_Handler,
		},
		{
			MethodName: "RemoveChallengeFromLocation",
			Handler:    _LocationService_RemoveChallengeFromLocation_Handler,
		},
		{
			MethodName: "GetChallengesFromLocation",
			Handler:    _LocationService_GetChallengesFromLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ecooda/v1/ecooda.proto",
}

const (
	ChallengeService_GetChallengeItemsBatch_FullMethodName      = "/ecooda.v1.ChallengeService/GetChallengeItemsBatch"
	ChallengeService_GetChallengeCollection_FullMethodName      = "/ecooda.v1.ChallengeService/GetChallengeCollection"
	ChallengeService_GetChallengeItem_FullMethodName            = "/ecooda.v1.ChallengeService/GetChallengeItem"
	ChallengeService_CreateChallenge_FullMethodName             = "/ecooda.v1.ChallengeService/CreateChallenge"
	ChallengeService_UpdateChallenge_FullMethodName             = "/ecooda.v1.ChallengeService/UpdateChallenge"
	ChallengeService_DeleteChallenge_FullMethodName             = "/ecooda.v1.ChallengeService/DeleteChallenge"
	ChallengeService_AddCategoryToChallenge_FullMethodName      = "/ecooda.v1.ChallengeService/AddCategoryToChallenge"
	ChallengeService_RemoveCategoryFromChallenge_FullMethodName = "/ecooda.v1.ChallengeService/RemoveCategoryFromChallenge"
	ChallengeService_GetCategoryCollection_FullMethodName       = "/ecooda.v1.ChallengeService/GetCategoryCollection"
	ChallengeService_GetCategoryItem_FullMethodName             = "/ecooda.v1.ChallengeService/GetCategoryItem"
	ChallengeService_CreateCategory_FullMethodName              = "/ecooda.v1.ChallengeService/CreateCategory"
	ChallengeService_UpdateCategory_FullMethodName              = "/ecooda.v1.ChallengeService/UpdateCategory"
	ChallengeService_DeleteCategory_FullMethodName              = "/ecooda.v1.ChallengeService/DeleteCategory"
)

// ChallengeServiceClient is the client API for ChallengeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChallengeServiceClient interface {
	// private API
	GetChallengeItemsBatch(ctx context.Context, in *GetChallengeItemsBatchRequest, opts ...grpc.CallOption) (*GetChallengeItemsBatchResponse, error)
	// public API
	GetChallengeCollection(ctx context.Context, in *GetChallengeCollectionRequest, opts ...grpc.CallOption) (*GetChallengeCollectionResponse, error)
	GetChallengeItem(ctx context.Context, in *GetChallengeItemRequest, opts ...grpc.CallOption) (*GetChallengeItemResponse, error)
	CreateChallenge(ctx context.Context, in *CreateChallengeRequest, opts ...grpc.CallOption) (*CreateChallengeResponse, error)
	UpdateChallenge(ctx context.Context, in *UpdateChallengeRequest, opts ...grpc.CallOption) (*UpdateChallengeResponse, error)
	DeleteChallenge(ctx context.Context, in *DeleteChallengeRequest, opts ...grpc.CallOption) (*DeleteChallengeResponse, error)
	AddCategoryToChallenge(ctx context.Context, in *AddCategoryToChallengeRequest, opts ...grpc.CallOption) (*AddCategoryToChallengeResponse, error)
	RemoveCategoryFromChallenge(ctx context.Context, in *RemoveCategoryFromChallengeRequest, opts ...grpc.CallOption) (*RemoveCategoryFromChallengeResponse, error)
	GetCategoryCollection(ctx context.Context, in *GetCategoryCollectionRequest, opts ...grpc.CallOption) (*GetCategoryCollectionResponse, error)
	GetCategoryItem(ctx context.Context, in *GetCategoryItemRequest, opts ...grpc.CallOption) (*GetCategoryItemResponse, error)
	CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*CreateCategoryResponse, error)
	UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*UpdateCategoryResponse, error)
	DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*DeleteCategoryResponse, error)
}

type challengeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChallengeServiceClient(cc grpc.ClientConnInterface) ChallengeServiceClient {
	return &challengeServiceClient{cc}
}

func (c *challengeServiceClient) GetChallengeItemsBatch(ctx context.Context, in *GetChallengeItemsBatchRequest, opts ...grpc.CallOption) (*GetChallengeItemsBatchResponse, error) {
	out := new(GetChallengeItemsBatchResponse)
	err := c.cc.Invoke(ctx, ChallengeService_GetChallengeItemsBatch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) GetChallengeCollection(ctx context.Context, in *GetChallengeCollectionRequest, opts ...grpc.CallOption) (*GetChallengeCollectionResponse, error) {
	out := new(GetChallengeCollectionResponse)
	err := c.cc.Invoke(ctx, ChallengeService_GetChallengeCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) GetChallengeItem(ctx context.Context, in *GetChallengeItemRequest, opts ...grpc.CallOption) (*GetChallengeItemResponse, error) {
	out := new(GetChallengeItemResponse)
	err := c.cc.Invoke(ctx, ChallengeService_GetChallengeItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) CreateChallenge(ctx context.Context, in *CreateChallengeRequest, opts ...grpc.CallOption) (*CreateChallengeResponse, error) {
	out := new(CreateChallengeResponse)
	err := c.cc.Invoke(ctx, ChallengeService_CreateChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) UpdateChallenge(ctx context.Context, in *UpdateChallengeRequest, opts ...grpc.CallOption) (*UpdateChallengeResponse, error) {
	out := new(UpdateChallengeResponse)
	err := c.cc.Invoke(ctx, ChallengeService_UpdateChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) DeleteChallenge(ctx context.Context, in *DeleteChallengeRequest, opts ...grpc.CallOption) (*DeleteChallengeResponse, error) {
	out := new(DeleteChallengeResponse)
	err := c.cc.Invoke(ctx, ChallengeService_DeleteChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) AddCategoryToChallenge(ctx context.Context, in *AddCategoryToChallengeRequest, opts ...grpc.CallOption) (*AddCategoryToChallengeResponse, error) {
	out := new(AddCategoryToChallengeResponse)
	err := c.cc.Invoke(ctx, ChallengeService_AddCategoryToChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) RemoveCategoryFromChallenge(ctx context.Context, in *RemoveCategoryFromChallengeRequest, opts ...grpc.CallOption) (*RemoveCategoryFromChallengeResponse, error) {
	out := new(RemoveCategoryFromChallengeResponse)
	err := c.cc.Invoke(ctx, ChallengeService_RemoveCategoryFromChallenge_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) GetCategoryCollection(ctx context.Context, in *GetCategoryCollectionRequest, opts ...grpc.CallOption) (*GetCategoryCollectionResponse, error) {
	out := new(GetCategoryCollectionResponse)
	err := c.cc.Invoke(ctx, ChallengeService_GetCategoryCollection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) GetCategoryItem(ctx context.Context, in *GetCategoryItemRequest, opts ...grpc.CallOption) (*GetCategoryItemResponse, error) {
	out := new(GetCategoryItemResponse)
	err := c.cc.Invoke(ctx, ChallengeService_GetCategoryItem_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*CreateCategoryResponse, error) {
	out := new(CreateCategoryResponse)
	err := c.cc.Invoke(ctx, ChallengeService_CreateCategory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*UpdateCategoryResponse, error) {
	out := new(UpdateCategoryResponse)
	err := c.cc.Invoke(ctx, ChallengeService_UpdateCategory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*DeleteCategoryResponse, error) {
	out := new(DeleteCategoryResponse)
	err := c.cc.Invoke(ctx, ChallengeService_DeleteCategory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChallengeServiceServer is the server API for ChallengeService service.
// All implementations must embed UnimplementedChallengeServiceServer
// for forward compatibility
type ChallengeServiceServer interface {
	// private API
	GetChallengeItemsBatch(context.Context, *GetChallengeItemsBatchRequest) (*GetChallengeItemsBatchResponse, error)
	// public API
	GetChallengeCollection(context.Context, *GetChallengeCollectionRequest) (*GetChallengeCollectionResponse, error)
	GetChallengeItem(context.Context, *GetChallengeItemRequest) (*GetChallengeItemResponse, error)
	CreateChallenge(context.Context, *CreateChallengeRequest) (*CreateChallengeResponse, error)
	UpdateChallenge(context.Context, *UpdateChallengeRequest) (*UpdateChallengeResponse, error)
	DeleteChallenge(context.Context, *DeleteChallengeRequest) (*DeleteChallengeResponse, error)
	AddCategoryToChallenge(context.Context, *AddCategoryToChallengeRequest) (*AddCategoryToChallengeResponse, error)
	RemoveCategoryFromChallenge(context.Context, *RemoveCategoryFromChallengeRequest) (*RemoveCategoryFromChallengeResponse, error)
	GetCategoryCollection(context.Context, *GetCategoryCollectionRequest) (*GetCategoryCollectionResponse, error)
	GetCategoryItem(context.Context, *GetCategoryItemRequest) (*GetCategoryItemResponse, error)
	CreateCategory(context.Context, *CreateCategoryRequest) (*CreateCategoryResponse, error)
	UpdateCategory(context.Context, *UpdateCategoryRequest) (*UpdateCategoryResponse, error)
	DeleteCategory(context.Context, *DeleteCategoryRequest) (*DeleteCategoryResponse, error)
	mustEmbedUnimplementedChallengeServiceServer()
}

// UnimplementedChallengeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChallengeServiceServer struct {
}

func (UnimplementedChallengeServiceServer) GetChallengeItemsBatch(context.Context, *GetChallengeItemsBatchRequest) (*GetChallengeItemsBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChallengeItemsBatch not implemented")
}
func (UnimplementedChallengeServiceServer) GetChallengeCollection(context.Context, *GetChallengeCollectionRequest) (*GetChallengeCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChallengeCollection not implemented")
}
func (UnimplementedChallengeServiceServer) GetChallengeItem(context.Context, *GetChallengeItemRequest) (*GetChallengeItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChallengeItem not implemented")
}
func (UnimplementedChallengeServiceServer) CreateChallenge(context.Context, *CreateChallengeRequest) (*CreateChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChallenge not implemented")
}
func (UnimplementedChallengeServiceServer) UpdateChallenge(context.Context, *UpdateChallengeRequest) (*UpdateChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChallenge not implemented")
}
func (UnimplementedChallengeServiceServer) DeleteChallenge(context.Context, *DeleteChallengeRequest) (*DeleteChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChallenge not implemented")
}
func (UnimplementedChallengeServiceServer) AddCategoryToChallenge(context.Context, *AddCategoryToChallengeRequest) (*AddCategoryToChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCategoryToChallenge not implemented")
}
func (UnimplementedChallengeServiceServer) RemoveCategoryFromChallenge(context.Context, *RemoveCategoryFromChallengeRequest) (*RemoveCategoryFromChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCategoryFromChallenge not implemented")
}
func (UnimplementedChallengeServiceServer) GetCategoryCollection(context.Context, *GetCategoryCollectionRequest) (*GetCategoryCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryCollection not implemented")
}
func (UnimplementedChallengeServiceServer) GetCategoryItem(context.Context, *GetCategoryItemRequest) (*GetCategoryItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryItem not implemented")
}
func (UnimplementedChallengeServiceServer) CreateCategory(context.Context, *CreateCategoryRequest) (*CreateCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCategory not implemented")
}
func (UnimplementedChallengeServiceServer) UpdateCategory(context.Context, *UpdateCategoryRequest) (*UpdateCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCategory not implemented")
}
func (UnimplementedChallengeServiceServer) DeleteCategory(context.Context, *DeleteCategoryRequest) (*DeleteCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCategory not implemented")
}
func (UnimplementedChallengeServiceServer) mustEmbedUnimplementedChallengeServiceServer() {}

// UnsafeChallengeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChallengeServiceServer will
// result in compilation errors.
type UnsafeChallengeServiceServer interface {
	mustEmbedUnimplementedChallengeServiceServer()
}

func RegisterChallengeServiceServer(s grpc.ServiceRegistrar, srv ChallengeServiceServer) {
	s.RegisterService(&ChallengeService_ServiceDesc, srv)
}

func _ChallengeService_GetChallengeItemsBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChallengeItemsBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).GetChallengeItemsBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_GetChallengeItemsBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).GetChallengeItemsBatch(ctx, req.(*GetChallengeItemsBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_GetChallengeCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChallengeCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).GetChallengeCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_GetChallengeCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).GetChallengeCollection(ctx, req.(*GetChallengeCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_GetChallengeItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChallengeItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).GetChallengeItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_GetChallengeItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).GetChallengeItem(ctx, req.(*GetChallengeItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_CreateChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).CreateChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_CreateChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).CreateChallenge(ctx, req.(*CreateChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_UpdateChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).UpdateChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_UpdateChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).UpdateChallenge(ctx, req.(*UpdateChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_DeleteChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).DeleteChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_DeleteChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).DeleteChallenge(ctx, req.(*DeleteChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_AddCategoryToChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCategoryToChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).AddCategoryToChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_AddCategoryToChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).AddCategoryToChallenge(ctx, req.(*AddCategoryToChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_RemoveCategoryFromChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCategoryFromChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).RemoveCategoryFromChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_RemoveCategoryFromChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).RemoveCategoryFromChallenge(ctx, req.(*RemoveCategoryFromChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_GetCategoryCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoryCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).GetCategoryCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_GetCategoryCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).GetCategoryCollection(ctx, req.(*GetCategoryCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_GetCategoryItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoryItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).GetCategoryItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_GetCategoryItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).GetCategoryItem(ctx, req.(*GetCategoryItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_CreateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).CreateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_CreateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).CreateCategory(ctx, req.(*CreateCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_UpdateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).UpdateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_UpdateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).UpdateCategory(ctx, req.(*UpdateCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_DeleteCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).DeleteCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_DeleteCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).DeleteCategory(ctx, req.(*DeleteCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChallengeService_ServiceDesc is the grpc.ServiceDesc for ChallengeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChallengeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ecooda.v1.ChallengeService",
	HandlerType: (*ChallengeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetChallengeItemsBatch",
			Handler:    _ChallengeService_GetChallengeItemsBatch_Handler,
		},
		{
			MethodName: "GetChallengeCollection",
			Handler:    _ChallengeService_GetChallengeCollection_Handler,
		},
		{
			MethodName: "GetChallengeItem",
			Handler:    _ChallengeService_GetChallengeItem_Handler,
		},
		{
			MethodName: "CreateChallenge",
			Handler:    _ChallengeService_CreateChallenge_Handler,
		},
		{
			MethodName: "UpdateChallenge",
			Handler:    _ChallengeService_UpdateChallenge_Handler,
		},
		{
			MethodName: "DeleteChallenge",
			Handler:    _ChallengeService_DeleteChallenge_Handler,
		},
		{
			MethodName: "AddCategoryToChallenge",
			Handler:    _ChallengeService_AddCategoryToChallenge_Handler,
		},
		{
			MethodName: "RemoveCategoryFromChallenge",
			Handler:    _ChallengeService_RemoveCategoryFromChallenge_Handler,
		},
		{
			MethodName: "GetCategoryCollection",
			Handler:    _ChallengeService_GetCategoryCollection_Handler,
		},
		{
			MethodName: "GetCategoryItem",
			Handler:    _ChallengeService_GetCategoryItem_Handler,
		},
		{
			MethodName: "CreateCategory",
			Handler:    _ChallengeService_CreateCategory_Handler,
		},
		{
			MethodName: "UpdateCategory",
			Handler:    _ChallengeService_UpdateCategory_Handler,
		},
		{
			MethodName: "DeleteCategory",
			Handler:    _ChallengeService_DeleteCategory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ecooda/v1/ecooda.proto",
}
